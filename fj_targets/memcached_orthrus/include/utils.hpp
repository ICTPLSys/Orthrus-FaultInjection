#pragma once

#include <cstddef>
#include <cstdint>
#include <memory>
#include <random>
#include <type_traits>
#include <vector>

#define DEBUG(...)                                  \
    fprintf(stderr, "%s:%d: ", __FILE__, __LINE__), \
        fprintf(stderr, __VA_ARGS__), fprintf(stderr, "\n")

constexpr size_t CACHELINE_SIZE = 64;

inline void *add_byte_offset(void *ptr, size_t offset) {
    return reinterpret_cast<void *>(reinterpret_cast<std::byte *>(ptr) +
                                    offset);
}

inline const void *add_byte_offset(const void *ptr, size_t offset) {
    return reinterpret_cast<const void *>(
        reinterpret_cast<const std::byte *>(ptr) + offset);
}

inline void *sub_byte_offset(void *ptr, size_t offset) {
    return reinterpret_cast<void *>(reinterpret_cast<std::byte *>(ptr) -
                                    offset);
}

inline const void *sub_byte_offset(const void *ptr, size_t offset) {
    return reinterpret_cast<const void *>(
        reinterpret_cast<const std::byte *>(ptr) - offset);
}

inline size_t ptr_distance(const void *ptr1, const void *ptr2) {
    return reinterpret_cast<const std::byte *>(ptr2) -
           reinterpret_cast<const std::byte *>(ptr1);
}

inline size_t align_size_to_cacheline(size_t size) {
    return (size + CACHELINE_SIZE - 1) & ~(CACHELINE_SIZE - 1);
}

static constexpr bool is_power_of_2(uint32_t N) {
    return (N > 0) && !(N & (N - 1));
}

#define FORCE_INLINE inline __attribute__((always_inline))

/**
 * Example usage:
 *
 *    std::random_device rd;
 *    std::mt19937 gen(rd());
 *    zipf_table_distribution<> zipf(300);
 *
 *    for (int i = 0; i < 100; i++)
 *        printf("draw %d %d\n", i, zipf(gen));
 */
template <class IntType = unsigned long, class RealType = double>
class zipf_table_distribution {
public:
    typedef IntType result_type;

    static_assert(std::numeric_limits<IntType>::is_integer, "");
    static_assert(!std::numeric_limits<RealType>::is_integer, "");

    /// zipf_table_distribution(N, s)
    /// Zipf distribution for `N` items, in the range `[1,N]` inclusive.
    /// The distribution follows the power-law 1/n^s with exponent `s`.
    /// This uses a table-lookup, and thus provides values more
    /// quickly than zipf_distribution. However, the table can take
    /// up a considerable amount of RAM, and initializing this table
    /// can consume significant time.
    zipf_table_distribution(const IntType n, const RealType q = 1.0);
    void reset();
    IntType operator()(std::mt19937 &rng);
    /// Returns the parameter the distribution was constructed with.
    RealType s() const;
    /// Returns the minimum value potentially generated by the distribution.
    result_type min() const;
    /// Returns the maximum value potentially generated by the distribution.
    result_type max() const;

private:
    std::vector<RealType> pdf_;                 ///< Prob. distribution
    IntType n_;                                 ///< Number of elements
    RealType q_;                                ///< Exponent
    std::discrete_distribution<IntType> dist_;  ///< Draw generator

    /** Initialize the probability mass function */
    IntType init(const IntType n, const RealType q);
};

template <class IntType, class RealType>
FORCE_INLINE
zipf_table_distribution<IntType, RealType>::zipf_table_distribution(
    const IntType n, const RealType q)
    : n_(init(n, q)), q_(q), dist_(pdf_.begin(), pdf_.end()) {}

template <class IntType, class RealType>
FORCE_INLINE void zipf_table_distribution<IntType, RealType>::reset() {}

template <class IntType, class RealType>
FORCE_INLINE IntType
zipf_table_distribution<IntType, RealType>::operator()(std::mt19937 &rng) {
    return dist_(rng) - 1;
}

template <class IntType, class RealType>
FORCE_INLINE RealType zipf_table_distribution<IntType, RealType>::s() const {
    return q_;
}

template <class IntType, class RealType>
FORCE_INLINE typename zipf_table_distribution<IntType, RealType>::result_type
zipf_table_distribution<IntType, RealType>::min() const {
    return 0;
}

template <class IntType, class RealType>
FORCE_INLINE typename zipf_table_distribution<IntType, RealType>::result_type
zipf_table_distribution<IntType, RealType>::max() const {
    return n_ - 1;
}

template <class IntType, class RealType>
FORCE_INLINE IntType zipf_table_distribution<IntType, RealType>::init(
    const IntType n, const RealType q) {
    pdf_.reserve(n + 1);
    pdf_.emplace_back(0.0);
    for (IntType i = 1; i <= n; i++) {
        pdf_.emplace_back(std::pow((double)i, -q));
    }
    return n;
}

// TODO: detect the cpu freq automatically
constexpr static const uint64_t kCpuMhzNorm = 2600;
constexpr static const uint64_t kCpuMhzReal = 3400;

static inline uint64_t rdtsc() {
    uint32_t lo, hi;
    asm volatile("rdtsc" : "=a"(lo), "=d"(hi));
    return (uint64_t)hi << 32 | lo;
}

static inline uint64_t microsecond(uint64_t start, uint64_t end) {
    return (end - start) / kCpuMhzNorm;
}

static inline uint64_t nanosecond(uint64_t start, uint64_t end) {
    return (end - start) * 1000 / kCpuMhzNorm;
}

static inline void my_usleep(int us) {
    for (uint64_t i = 0; i < kCpuMhzReal * us; ++i) {
        asm volatile("nop");
    }
}

static inline void my_nsleep(int ns) {
    for (uint64_t i = 0; i < ns * kCpuMhzReal / 1000; ++i) {
        asm volatile("nop");
    }
}

static inline void bind_core(pthread_t t, int core_id) {
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(core_id, &cpuset);
    int r = pthread_setaffinity_np(t, sizeof(cpu_set_t), &cpuset);
    if (r != 0) fprintf(stderr, "Error bind_core: %d\n", r), abort();
}
