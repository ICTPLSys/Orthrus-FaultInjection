diff --git a/include/context/run.hpp b/include/context/run.hpp
index 7aa485f..30735d2 100644
--- a/include/context/run.hpp
+++ b/include/context/run.hpp
@@ -41,10 +41,64 @@ inline T *shadow_init(T *ptr) {
     return ptr;
 }
 
+__attribute__((target("sse4.2"))) inline uint32_t calculate_crc32_app(const void* data,
+    std::size_t length) {
+    // 初始化CRC值为全1（这是CRC32的标准初始值）
+    std::uint32_t crc = ~0U;
+    const auto* buffer = static_cast<const unsigned char*>(data);
+
+    // 处理未对齐的前缀字节，直到达到8字节对齐
+    while (length > 0 && reinterpret_cast<std::uintptr_t>(buffer) % 8 != 0) {
+    crc = _mm_crc32_u8(crc, *buffer);
+    buffer++;
+    length--;
+    }
+
+    // 以8字节为单位进行处理（最高效）
+    const auto* buffer64 = reinterpret_cast<const std::uint64_t*>(buffer);
+    while (length >= 8) {
+    crc = _mm_crc32_u64(crc, *buffer64);
+    buffer64++;
+    length -= 8;
+    }
+
+    // 处理剩余的字节
+    buffer = reinterpret_cast<const unsigned char*>(buffer64);
+
+    // 尝试以4字节处理
+    if (length >= 4) {
+    auto value32 = *reinterpret_cast<const std::uint32_t*>(buffer);
+    crc = _mm_crc32_u32(crc, value32);
+    buffer += 4;
+    length -= 4;
+    }
+
+    // 尝试以2字节处理
+    if (length >= 2) {
+    auto value16 = *reinterpret_cast<const std::uint16_t*>(buffer);
+    crc = _mm_crc32_u16(crc, value16);
+    buffer += 2;
+    length -= 2;
+    }
+
+    // 处理最后可能剩余的1个字节
+    if (length > 0) {
+    crc = _mm_crc32_u8(crc, *buffer);
+    }
+
+    // 对结果取反，得到最终的CRC32值
+    return ~crc;
+}
+
+
+inline checksum_t compute_checksum_app(const void* ptr, size_t size) {
+    return calculate_crc32_app(ptr, size);
+}
+
 template <typename T>
 inline void shadow_commit(const T *shadow, T *real) {
     size_t size = get_size(real);
-    *(checksum_t *)add_byte_offset(real, size) = compute_checksum(real, size);
+    *(checksum_t *)add_byte_offset(real, size) = compute_checksum_app(real, size);
 }
 
 template <typename T>
@@ -54,7 +108,7 @@ template <typename T>
 inline void store_obj(T *dst, const T *src) {
     size_t size = get_size(src);
     memcpy(dst, src, size);
-    *(checksum_t *)add_byte_offset(dst, size) = compute_checksum(src, size);
+    *(checksum_t *)add_byte_offset(dst, size) = compute_checksum_app(src, size);
 }
 
 inline const void *load_ptr(const void *ptr) {
diff --git a/include/context/validation.hpp b/include/context/validation.hpp
index 151051d..a2e9ded 100644
--- a/include/context/validation.hpp
+++ b/include/context/validation.hpp
@@ -45,11 +45,64 @@ inline T *shadow_init(T *ptr) {
     return (T *)shadow_buffer;
 }
 
+__attribute__((target("sse4.2"))) inline uint32_t calculate_crc32_val(const void* data,
+    std::size_t length) {
+    // 初始化CRC值为全1（这是CRC32的标准初始值）
+    std::uint32_t crc = ~0U;
+    const auto* buffer = static_cast<const unsigned char*>(data);
+
+    // 处理未对齐的前缀字节，直到达到8字节对齐
+    while (length > 0 && reinterpret_cast<std::uintptr_t>(buffer) % 8 != 0) {
+    crc = _mm_crc32_u8(crc, *buffer);
+    buffer++;
+    length--;
+    }
+
+    // 以8字节为单位进行处理（最高效）
+    const auto* buffer64 = reinterpret_cast<const std::uint64_t*>(buffer);
+    while (length >= 8) {
+    crc = _mm_crc32_u64(crc, *buffer64);
+    buffer64++;
+    length -= 8;
+    }
+
+    // 处理剩余的字节
+    buffer = reinterpret_cast<const unsigned char*>(buffer64);
+
+    // 尝试以4字节处理
+    if (length >= 4) {
+    auto value32 = *reinterpret_cast<const std::uint32_t*>(buffer);
+    crc = _mm_crc32_u32(crc, value32);
+    buffer += 4;
+    length -= 4;
+    }
+
+    // 尝试以2字节处理
+    if (length >= 2) {
+    auto value16 = *reinterpret_cast<const std::uint16_t*>(buffer);
+    crc = _mm_crc32_u16(crc, value16);
+    buffer += 2;
+    length -= 2;
+    }
+
+    // 处理最后可能剩余的1个字节
+    if (length > 0) {
+    crc = _mm_crc32_u8(crc, *buffer);
+    }
+
+    // 对结果取反，得到最终的CRC32值
+    return ~crc;
+}
+
+inline checksum_t compute_checksum_val(const void* ptr, size_t size) {
+    return calculate_crc32_val(ptr, size);
+}
+
 template <typename T>
 inline void shadow_commit(const T *shadow, T *real) {
     size_t size = get_size(shadow);
     validator_assert(size == get_size(real));
-    checksum_t computed = compute_checksum(shadow, size);
+    checksum_t computed = compute_checksum_val(shadow, size);
     checksum_t stored = *(checksum_t *)add_byte_offset(real, size);
     validator_assert(computed == stored);
 }
